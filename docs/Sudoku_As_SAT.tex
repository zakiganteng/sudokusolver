% vim: set fenc=utf-8 ft=latex encoding=utf-8
% -*- mode: latex; coding: UTF-8; -*-

\newif\ifdraft
\drafttrue % Draft mode -- comment this out before submission

\ifdraft
  \documentclass[conference,draftclsnofoot]{IEEEtran}
  \def\baselinestretch{1}
  \setlength{\marginparwidth}{2cm}
\else
  \documentclass[conference,final]{IEEEtran}
\fi

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}


\newcommand{\TheTitle}{Investigating the Effects of Extended Encoding Against
Minimal Encoding}
\newcommand{\TheKeywords}{Sudoku, SAT-solver, minimal encoding, extended encoding}
\newcommand{\TheAuthors}{Evan Wilde, Sebastien Guillemot, Shayla Redlin, Laura
Grondahl}
\newcommand{\TheSubject}{Solving sudoku of varying size and difficulty with a
SAT solver}
\usepackage[hyphens]{url}
\urlstyle{same}
\usepackage[unicode=true,
            bookmarks=false,breaklinks=false,pdfborder={0 0 0},
            backref=none,colorlinks=false]{hyperref}

\hypersetup{pdftitle={\TheTitle},
            pdfauthor={\TheAuthors},
            pdfkeywords={\TheKeywords},
            pdfsubject={\TheSubject},
            urlcolor=blue,citecolor=red}

\usepackage[nospace]{cite}
\usepackage{xspace}


% Fix any bad-hyphenations here
\hyphenation{}

\input{macros.tex}

\begin{document}

\title{\TheTitle}

\author{
\IEEEauthorblockA{\TheAuthors}
\IEEEauthorblockN{Department of Computer Science,
                    University of Victoria,
	    Canada.}}
\maketitle
\begin{abstract}
In this paper we explore solving sudoku as a SAT problem. Using encoding
methods described by Ines Lynce and Joel Ouaknine, we wrote a program to take
an unsolved sudoku puzzle, encode it in standard SAT-challenge (DIMACS) format,
run the SAT solver, and finally convert the results back to a sudoku board.
Lynce and Ouaknine identify a minimal encoding and an extended encoding in
their paper. We implemented both encodings in separate programs. The program is
capable of running on NxN puzzles where N is a perfect square. e.g 9x9, 16x6,
and 25x25 are all usable board sizes. Due to base conversions, our program is
only capable of going up to board sizes of 36x36. The paper presents the
runtime of the minimal encoding versus the extended encoding in the program
``minisat''. We also present the method by which our program was generalized to
handle puzzles of varying sizes, and how varying the size changes the runtime.
\end{abstract}
\begin{IEEEkeywords}
\TheKeywords
\end{IEEEkeywords}

\section{Introduction}
In this paper we explore solving sudoku as a SAT problem. Using encoding
methods described by Ines Lynce and Joel Ouaknine, we wrote a program to take
an unsolved sudoku puzzle, encode it in standard SAT-challenge (DIMACS) format,
run the SAT solver, and finally convert the results back to a sudoku board.
Lynce and Ouaknine identify a minimal encoding and an extended encoding in
their paper. We implemented both encodings in separate programs. The program is
capable of running on NxN puzzles where N is a perfect square. e.g 9x9, 16x6,
and 25x25 are all usable board sizes. Due to base conversions, our program is
only capable of going up to board sizes of 36x36. The paper presents the
runtime of the minimal encoding versus the extended encoding in the program
``minisat''. We also present the method by which our program was generalized to
handle puzzles of varying sizes, and how varying the size changes the runtime.

\section{Data sample}
We found an online board
generator\footnote{\url{http://sudoku-puzzles.merschat.com/}} with difficulties
ranging from ``easy'' to ``Lex Luthor''. Easier puzzles have many blocks
originally filled in, whereas puzzles at Lex Luthor difficulty only have a few
positions filled in, adding more potentially ambiguous cases. On a 9x9 board,
an ``easy'' board may have more than 50\% of the squares filled in, whereas a
``Lex Luthor'' board may have as few as 4 squares filled in.

\section{Methodologies}
To test the benefits and drawbacks of the presented minimal and extended
encodings, we performed the following test to determine how each scales across
the difficulty of the puzzle and the size of the puzzle.
We sample the results on a 3rd Gen. intel core i5-3337U cpu clocked at 1.80Ghz.
Our tests,
\begin{enumerate}
	\item Minimal encoding on 9x9 puzzles of ``easy'', ``medium'', and
		``lex luthor'' difficulty levels.
	\item Minimal encoding on unsolvable 9x9 puzzles of ``easy'',
		``medium'' and ``lex luthor'' difficult levels.
	\item Extended encoding on 9x9 puzzles of ``easy'', ``medium'', and
		``lex luthor'' difficulty levels.
	\item Extended encoding on unsolvable 9x9 puzzles of ``easy'',
		``medium'' and ``lex luthor'' difficult levels.

	\item Minimal encoding versus extended encoding on 16x16 puzzles
\end{enumerate}

\section{Results}

\evantodo{Reformat this sucker}
\subsection{Test 0}

% \begin{tabular}{l l l l}
% 	25x25 Lex Luther


Minimal encoding on a puzzle that is solvable:
(25x25 Lex Luther but solvable):
Clauses  :413382
Variables: 15625

Parse time 0.08s
restarts              : 13
conflicts             : 1987           (13863 /sec)
decisions             : 25785          (0.00 \% random) (179896 /sec)
propagations          : 249614         (1741497 /sec)
conflict literals     : 157229         (0.93 \% deleted)
Memory used           : 38.00 MB
CPU time              : 0.143333 s

Minimal encoding on a puzzle that is not solvable:
(25x25 Not solvable):
Parse Time:		: 0.05
Clauses		      : 1474 
Variables	      : 15625
restarts              : 0
conflicts             : 0              (0 /sec)
decisions             : 0              (-nan \% random) (0 /sec)
propagations          : 104            (1950 /sec)
conflict literals     : 0              (-nan \% deleted)
Memory used           : 20.00 MB
CPU time              : 0.053333 s

\subsection{Test 1}
Minimal encoding versus extended encoding on a medium puzzle:

\subsection{Test 2}
Minimal encoding versus extended encoding on a difficult puzzle:


\subsection{Test 3}
Minimal encoding versus extended encoding on an easy puzzle:

\subsection{Test 4}
Minimal encoding versus extended encoding on an unsolvable puzzle:

\subsection{Test 5}
Minimal versus extended encoding on a 16x16 puzzle:

\subsection{Test 6}
Sum times from 4 different puzzles solved with the minimal encoding and compute
the average.



\subsection{Limitations}
Theoretically our program can use any $n$x$n$ puzzle, so long a $n$ is a
perfect square; however, due to limitations of encoding numbers larger than z,
our program can only take puzzles up to 36x36. A possible method of extending
the usage of the solver is to allow a delimiter between values in each cell.


Can't do 4x4 puzzles.

\section{Discussion}
From tests 1, 2, 3, 4, and 5 it was found that...  It seems like the minimal
encoding should always be faster; however, the extended encoding is more
efficient for difficult puzzles. \(?\)
Theorectically, our program can take any nxn puzzle as long as n is a perfect
square; however, due to the limitations of encoding numbers larger than 10 in
one character, our program can only take puzzles up to 36x36. One possible way
to encode nxn puzzles with n larger than 36 is to have whitespace between each
entry in the input file and have the program reading the input look for
whitespace to determine individual entries.

\section{Conclusion}
After testing our sudoku solver on a variety of input puzzles, it was found
that...  Our program can solve nxn puzzles up to $n=36$, but n must be a
perfect square.  ...


\end{document}
